{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Constants, PromptState, BlacklistedEQParams } from \"../utils/Constants\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ScopeSet } from \"../ScopeSet\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { CryptoUtils } from \"../utils/CryptoUtils\";\n/**\n * @hidden\n */\n\nvar RequestUtils =\n/** @class */\nfunction () {\n  function RequestUtils() {}\n  /**\n   * @ignore\n   *\n   * @param request\n   * @param isLoginCall\n   * @param requestType\n   * @param redirectCallbacksSet\n   * @param cacheStorage\n   * @param clientId\n   *\n   * validates all request parameters and generates a consumable request object\n   */\n\n\n  RequestUtils.validateRequest = function (request, isLoginCall, clientId, requestType, redirectCallbacksSet) {\n    // Throw error if request is empty for acquire * calls\n    if (!isLoginCall && !request) {\n      throw ClientConfigurationError.createEmptyRequestError();\n    } // Throw error if callbacks are not set before redirect\n\n\n    if (requestType == Constants.interactionTypeRedirect && !redirectCallbacksSet) {\n      throw ClientConfigurationError.createRedirectCallbacksNotSetError();\n    }\n\n    var scopes;\n    var extraQueryParameters;\n\n    if (request) {\n      // if extraScopesToConsent is passed in loginCall, append them to the login request; Validate and filter scopes (the validate function will throw if validation fails)\n      scopes = isLoginCall ? ScopeSet.appendScopes(request.scopes, request.extraScopesToConsent) : request.scopes;\n      ScopeSet.validateInputScope(scopes, !isLoginCall, clientId); // validate prompt parameter\n\n      this.validatePromptParameter(request.prompt); // validate extraQueryParameters\n\n      extraQueryParameters = this.validateEQParameters(request.extraQueryParameters, request.claimsRequest); // validate claimsRequest\n\n      this.validateClaimsRequest(request.claimsRequest);\n    } // validate and generate state and correlationId\n\n\n    var state = this.validateAndGenerateState(request && request.state);\n    var correlationId = this.validateAndGenerateCorrelationId(request && request.correlationId);\n\n    var validatedRequest = tslib_1.__assign({}, request, {\n      extraQueryParameters: extraQueryParameters,\n      scopes: scopes,\n      state: state,\n      correlationId: correlationId\n    });\n\n    return validatedRequest;\n  };\n  /**\n   * @ignore\n   *\n   * Utility to test if valid prompt value is passed in the request\n   * @param request\n   */\n\n\n  RequestUtils.validatePromptParameter = function (prompt) {\n    if (prompt) {\n      if ([PromptState.LOGIN, PromptState.SELECT_ACCOUNT, PromptState.CONSENT, PromptState.NONE].indexOf(prompt) < 0) {\n        throw ClientConfigurationError.createInvalidPromptError(prompt);\n      }\n    }\n  };\n  /**\n   * @ignore\n   *\n   * Removes unnecessary or duplicate query parameters from extraQueryParameters\n   * @param request\n   */\n\n\n  RequestUtils.validateEQParameters = function (extraQueryParameters, claimsRequest) {\n    var eQParams = tslib_1.__assign({}, extraQueryParameters);\n\n    if (!eQParams) {\n      return null;\n    }\n\n    if (claimsRequest) {\n      // this.logger.warning(\"Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.\");\n      delete eQParams[Constants.claims];\n    }\n\n    BlacklistedEQParams.forEach(function (param) {\n      if (eQParams[param]) {\n        // this.logger.warning(\"Removed duplicate \" + param + \" from extraQueryParameters. Please use the \" + param + \" field in request object.\");\n        delete eQParams[param];\n      }\n    });\n    return eQParams;\n  };\n  /**\n   * @ignore\n   *\n   * Validates the claims passed in request is a JSON\n   * TODO: More validation will be added when the server team tells us how they have actually implemented claims\n   * @param claimsRequest\n   */\n\n\n  RequestUtils.validateClaimsRequest = function (claimsRequest) {\n    if (!claimsRequest) {\n      return;\n    }\n\n    var claims;\n\n    try {\n      claims = JSON.parse(claimsRequest);\n    } catch (e) {\n      throw ClientConfigurationError.createClaimsRequestParsingError(e);\n    }\n  };\n  /**\n   * @ignore\n   *\n   * generate unique state per request\n   * @param request\n   */\n\n\n  RequestUtils.validateAndGenerateState = function (state) {\n    // append GUID to user set state  or set one for the user if null\n    return !StringUtils.isEmpty(state) ? CryptoUtils.createNewGuid() + \"|\" + state : CryptoUtils.createNewGuid();\n  };\n  /**\n   * @ignore\n   *\n   * validate correlationId and generate if not valid or not set by the user\n   * @param correlationId\n   */\n\n\n  RequestUtils.validateAndGenerateCorrelationId = function (correlationId) {\n    // validate user set correlationId or set one for the user if null\n    if (correlationId && !CryptoUtils.isGuid(correlationId)) {\n      throw ClientConfigurationError.createInvalidCorrelationIdError();\n    }\n\n    return CryptoUtils.isGuid(correlationId) ? correlationId : CryptoUtils.createNewGuid();\n  };\n\n  return RequestUtils;\n}();\n\nexport { RequestUtils };","map":null,"metadata":{},"sourceType":"module"}